\\clock_1HZ
module clockdivider1(
    output reg clk_1HZ,
    input clk_50,
    input rst,
    output reg [24:0]count
    );
        
    always @ (posedge clk_50 or posedge rst)
    
    if (rst)
    begin
    clk_1HZ<=0;
    count<=25'd0;
    end
    else if (count==25'd24999999)
    begin 
    count<=25'd0;
    clk_1HZ<=~clk_1HZ;
     end
     else
     begin 
     count<=count+1;
     end
     
endmodule









\\testbench_1HZ

`timescale 1ns/1ns

module clk_1HZ_tb;
  reg clk_50_tb;
  reg rst_tb;
  wire [24:0]count_tb;
  wire clk_1HZ_tb;
  
  clockdivider1 dut( .clk_50(clk_50_tb), .rst(rst_tb), .clk_1HZ(clk_1HZ_tb), .count(count_tb));

initial
begin
  rst_tb=1;

  #10
  rst_tb=0;
  
  end

initial 
begin
  clk_50_tb=0;
  forever
  begin
    #10
    clk_50_tb=~clk_50_tb  ;
  end
end
initial
begin
$display ("\t\t\ttime,\tclk_50,\trst,\tclk_1HZ_tb,\tcount_tb");
$monitor ("\t%d,\t%b,\t%b,\t%b,\t\t%d",$time,clk_50_tb,rst_tb,clk_1HZ_tb,count_tb);
end 
initial
#10000
$finish;

endmodule







\\clock_TX
module clockdividerTX(
    output reg clk_19200,
    input clk_50,
    input rst,
    output reg [10:0]count
    
    );
    
    
    
    always @ (posedge clk_50 or posedge rst)
    
    if (rst)
    begin
    clk_19200<=0;
    count<=1302'd0;
    end
    else if (count==1302'd1302)
    begin 
    count<=1302'd0;
    clk_19200<=~clk_19200;
     end
     else
     begin 
     count<=count+1;
     end
     
endmodule









\\testbench TX

`timescale 1ns/1ns

module clockdividerTX_tb;
  reg clk_50_tb;
  reg rst_tb;
  wire [10:0]count_tb;
  wire clk_19200_tb;
  
  
clockdividerTX dut( .clk_50(clk_50_tb), .rst(rst_tb), .clk_19200(clk_19200_tb),.count(count_tb));

initial
begin
  rst_tb=1;

  #10
  rst_tb=0;
  
  
end

initial 
begin
  clk_50_tb=0;
  forever
  begin
    #10
    clk_50_tb=~clk_50_tb  ;
  end
end
initial
begin
$display ("\t\t\ttime,\tclk_50,\trst,\tclk_19200_tb,\tcount_tb");
$monitor ("\t%d,\t%b,\t%b,\t%b,\t\t%d",$time,clk_50_tb,rst_tb,clk_19200_tb,count_tb);
end 
initial
#100000
$finish;

endmodule









\\clock_baudrate
module baudrate(
    output reg tick,
    input clk,
    input rest,
    output reg [6:0]count
    
    );
    
    
    
    always @ (posedge clk or posedge rest)
    
    if (rest)
    begin
    tick<=0;
    count<=82'd0;
    end
    else if (count==82'd81)
    begin 
    count<=82'd0;
     tick<=~tick;
     end
     else
     begin 
     count<=count+1;
     end
     
endmodule







\\testbench_baudrate

`timescale 1ns/1ns

module baudrate_tb;
  reg clk_tb;
  reg rest_tb;
  wire [6:0]count_tb;
  wire tick_tb;
  
  
baudrate dut( .clk(clk_tb), .rest(rest_tb), .tick(tick_tb), .count(count_tb));

initial
begin
  rest_tb=1;

  #10
  rest_tb=0;
  
  
end

initial 
begin
  clk_tb=0;
  forever
  begin
    #10
    clk_tb=~clk_tb  ;
  end
end
initial
begin
$display ("\t\t\ttime,\tclk,\trest,\ttick_tb,\tcount_tb");
$monitor ("\t%d,\t%b,\t%b,\t%b,\t\t%d",$time,clk_tb,rest_tb,tick_tb,count_tb);
end 
initial

#10000
$finish;

endmodule




